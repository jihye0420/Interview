# 6장 인덱스
- **인덱스(INDEX)** : 데이터를 빠르게 조회할 수 있는 도구
    - **클러스터형 인덱스(Clustered Index)** : 기본키로 지정하면 자동 생성, 테이블에 1개만 가능, 자동 정렬 가능
        - 영어사전
    - **보조 인덱스(Secondary Index)** : 고유키로 지정하면 자동 생성되며, 여러개 가능, 자동 정렬 불가능
        - 찾아보기가 있는 일반적인 책과 같음
            - 단순 보조 인덱스 == 중복 허용
            - 고유 보조 인덱스 == 중복 허용하지 않음
    - **장점** : 데이터 조회 빠름, 빠른 응답 속도
    - **단점** : 필요 없는 인덱스를 생성하여 데이터베이스에서 차지하는 공간 늘어남, 더욱 속도 느려질 수 있음, 인덱스 공간을 위한 추가 공간 필요, 인덱스를 만드는데 시간이 오래 걸릴 수도 있음, SELECT가 아닌 UPDATE, DELETE가 자주 일어나면 오히려 성능이 나빠질 수도 있음
    - 하나의 열에 여러 개의 인덱스 생성 가능, 여러 개의 열 묶어서 하나의 인덱스 생성 가능
    
    ```sql
    # 인덱스 조회
    **SHOW INDEX FROM 테이블이름;**
    
    # 인덱스 크기 조회
    **SHOW TABLE STATUS LIKE 테이블이름;
    
    # 실제 인덱스 적용
    ALALYZE TABLE 테이블이름;**
    
    # 인덱스 생성
    **CREATE [UNIQUE] INDEX 인덱스이름 
       ON 테이블이름 (열이름) [ASC | DESC];**
    
    # 인덱스 삭제
    **DROP INDEX 인덱스이름 ON 테이블이름;** # 기본키, 고유키로 자동생성된 인덱스를 제거하지 못한다!
    
    # 하나의 테이블에 클러스터형, 보조형 인덱스가 모두 있는 경우, 보조 인덱스부터 제거하는 것이 더 좋다! 
    # => 데이터 재구성이 없기 때문에!
    ```
    
    - **인덱스의 내부 작동 원리**
        - **균형트리(B-TREE)** : **노드(데이터를 저장하는 공간)==페이지(Page, 최소한의 저장 단위, 16Kbyte)**
            - 루트 노드 - 리프 노드
            - 데이터 1건 입력 == 1개 페이지 필요
        - **SELECT ⇒ 데이터 조회 속도 향상**
        - **INSERT, UPDATE, DELETE** ⇒ **데이터 변경 작업 시** 성능이 나빠짐, 특히, INSERT시!!! 주의 
        ⇒ **페이지 분할 작업**이 발생하기 때문에 : 새로운 페이지를 준비해서 데이터를 나누는 작업이 필요하기 때문에 MySQL이 느려지고, 성능 저하됨
    - **인덱스의 구조**
        - 인덱스 검색 속도 : **클러스터형 인덱스** > 보조인덱스
            - 클러스터형 인덱스 : 데이터페이지가 따로 존재하지 않고 리프노드가 데이터페이지임,
                - Clustered Index는 물리적으로 정렬되어 있어 검색 속도가 Non-Clustered Index 보다 더 빠르다. 하지만 데이터의 입력. 수정, 삭제는 느리다.
                - 🌟**데이터 검색 순서 : 루트페이지 > 리프페이지(데이터 페이지)**
                
                **언제 사용 ?** 
                
                - 테이블 데이터가 자주 업데이트 되지 않는 경우
                - MAX, MIN, COUNT등의 쿼리로 **범위 또는 Group By** 등의 조회를 하는 경우
                - 항상 정렬 된 방식으로 데이터를 반환해야하는 경우
                    - 테이블은 정렬되어있기 때문에 ORDER BY 절을 활용해 모든 테이블 데이터를 스캔하지 않고 원하는 데이터를 조회할 수 있다.
                - 읽기 작업이 월등히 많은 경우, 이때 매우 빠르다.
                
                **단점**
                
                - **리프 페이지가 모두 차있는데 새로운 데이터가 추가될때 페이지 분할이 일어난다.**
                - **항상 순서를 유지해야 한다.**
            - 보조 인덱스 : 데이터페이지(인덱스)가 별도 공간에 만들어짐
                - 🌟**데이터 검색 순서 : 루트페이지 > 리프페이지 > 데이터 페이지 (Heap page)**
                
                **언제 사용?**
                
                - where절이나 Join 절과 같이 조건문을 활용하여 테이블을 필터링 하고자 할 경우
                - **데이터가 자주 업데이트 될 경우 ⇒ 매 삽입, 수정, 삭제에 정렬 시킬 필요가 없어 이 경우엔 유리**
                - 특정 컬럼이 쿼리에서 자주 사용 될 경우
                
                **단점**
                
                - **인덱스 페이지만을 위한 추가 저장공간이 필요하다.**
                - **데이터 접근 속도가 클러스터 인덱스보다 상대적으로 느리다**.
				
    - **인덱스 효과적으로 사용**
        - 하나의 열에 하나의 인덱스가 가장 일반적
        - where절에서 사용되는 열에 인덱스 생성, 자주 사용해야 가치가 있음
        - 데이터 중복이 높은 열은 인덱스를 만들면 별로 효과가 없음
        - 클러스터형 인덱스는 테이블당 하나만 생성가능
        - 사용하지 않는 인덱스는 제거하기